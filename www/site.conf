server {
	server_name ((DOMAIN));
	listen 8443 ssl;
	listen [::]:8443 ssl;
	http2 on;
	root /var/www/https;
	include /etc/nginx/sites-available/shared-ssl.inc;

	if ($block) { # set in badagents.conf
		return 444;
	}

	if ($request_method !~ ^(HEAD|GET)$) {
		return 444;
	}

	location ~* '/\.[^w]|^[\./]+(?:_|admin|ansible|aws|backup|b[ck]|build|cgi-bin|config(?:uration)?[\./]|curl|db|debug|dist|django|docker|ec[ps]|elastic|env(?:ironment)?\.|fetch|fixtures?|includes?|kubernetes|login|logs?|maven|modules|out|package|parameters\.|php|private|proxy|redirect|register|settings?|src|telescope|travis|uploads?|user|vendor|wordpress|wp)|credential|secret|\.(?:action|additional|aspx?|axd|bac?k|cfg|cgi|conf(ig)?|dist|env|ex[es]|groovy|ini|key|lock|log|module|old|php\d*|pl|properties|py|rb|sample|save|sh|sql|swp|te?mp|toml|ts|xsd|ya?ml)(?:[\./\?]|$)|~(?:[\./\?]|$)' {
		# obvious hack attempt
		include /etc/nginx/sites-available/hacker.inc;
	}

	location ~* '/(?:_|wp-|php$)|^/+(?:home|main|new|old|api|about|server-status|swagger.*|path_sql)(?:[/?]|$)|golem\.com|rest_route' {
		# likely hack attempt (but could also be a well-intentioned bot following a bad link, so don't punish them)
		lingering_close off;
		return 444;
	}

	gzip_static on;

	location ~* \.gz$ {
		# prevent direct access to static gzip files
		return 404;
	}

	add_header Cache-Control "public, max-age=600, stale-if-error=31536000" always;

	# https://developer.mozilla.org/en-US/observatory/analyze?host=davidje13.com
	add_header Content-Security-Policy "base-uri 'self'; default-src 'none'; img-src 'self'; style-src 'self'; form-action 'none'; frame-ancestors 'none'" always;
	add_header Cross-Origin-Embedder-Policy "require-corp" always;
	add_header Cross-Origin-Opener-Policy "same-origin" always;
	add_header Cross-Origin-Resource-Policy "same-origin" always;
	add_header Permissions-Policy "accelerometer=(), ambient-light-sensor=(), attribution-reporting=(), autoplay=(), bluetooth=(), browsing-topics=(), camera=(), captured-surface-control=(), compute-pressure=(), cross-origin-isolated=(), deferred-fetch=(), deferred-fetch-minimal=(), display-capture=(), encrypted-media=(), fullscreen=(), gamepad=(), geolocation=(), gyroscope=(), hid=(), identity-credentials-get=(), idle-detection=(), language-detector=(), local-fonts=(), magnetometer=(), microphone=(), midi=(), otp-credentials=(), payment=(), picture-in-picture=(), publickey-credentials-secret=(), publickey-credentials-get=(), screen-wake-lock=(), serial=(), speaker-selection=(), storage-access=(), summarizer=(), translator=(), usb=(), web-share=(), window-management=(), xr-spatial-tracking=()" always;
	add_header Referrer-Policy "no-referrer" always;
	add_header X-Content-Type-Options "nosniff" always;

	# https://xclacksoverhead.org/home/about
	add_header X-Clacks-Overhead "GNU Terry Pratchett" always;

	location = / {
		try_files /index.htm =404;
	}

	location ~* '^/index\.html?$' {
		expires max;
		return 301 /;
	}

	location = /security.txt { # old standardised location for security.txt
		expires max;
		return 301 /.well-known/security.txt;
	}

	location = /.well-known/traffic-advice {
		expires 30d;
		default_type "application/trafficadvice+json; charset=utf-8";
	}

	location /errors/ {
		internal;
	}

	location /retro/ {
		keepalive_timeout 0s;
		access_log off;
		expires max;
		return 301 https://retro.((DOMAIN))$request_uri;
	}

	location /retros/ {
		keepalive_timeout 0s;
		access_log off;
		expires max;
		return 301 https://retro.((DOMAIN))$request_uri;
	}

	error_page 404 /errors/404.htm;
}

server {
	server_name www.((DOMAIN));
	listen 8443 ssl;
	listen [::]:8443 ssl;
	http2 on;
	include /etc/nginx/sites-available/shared-ssl.inc;
	keepalive_timeout 0s;
	access_log off;
	expires max;

	if ($block) { # set in badagents.conf
		return 444;
	}

	if ($request_method !~ ^(HEAD|GET)$) {
		return 444;
	}

	location / {
		return 301 https://((DOMAIN))$request_uri;
	}

	# direct redirects (avoid extra hop)

	location ~* '^/index\.html?$' {
		return 301 https://((DOMAIN))/;
	}

	location /retro/ {
		return 301 https://retro.((DOMAIN))$request_uri;
	}

	location /retros/ {
		return 301 https://retro.((DOMAIN))$request_uri;
	}
}
